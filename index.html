<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bull vs Bear – Tap to Win</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      body { margin: 0; padding: 0; overflow: hidden; user-select: none; background:#000; }
      #game-container { margin: 0 auto; }
      canvas { touch-action: manipulation; }
    </style>
  </head>
  <body>
    <div id="game-container"></div>
    <script>
      // --------- Utils: Rounded Button Texture ---------
      function makeRoundedButtonTexture(scene, key, w, h, fillColor, strokeColor, radius = 12, strokeWidth = 2) {
        const g = scene.make.graphics({ x: 0, y: 0, add: false });
        g.fillStyle(fillColor, 1);
        g.lineStyle(strokeWidth, strokeColor, 1);

        const r = radius;
        g.beginPath();
        g.moveTo(r, 0);
        g.lineTo(w - r, 0);
        g.arc(w - r, r, r, -Math.PI/2, 0);
        g.lineTo(w, h - r);
        g.arc(w - r, h - r, r, 0, Math.PI/2);
        g.lineTo(r, h);
        g.arc(r, h - r, r, Math.PI/2, Math.PI);
        g.lineTo(0, r);
        g.arc(r, r, r, Math.PI, 1.5*Math.PI);
        g.closePath();
        g.fillPath();
        g.strokePath();

        g.generateTexture(key, w, h);
        g.destroy();
      }

      // ========= ЗАГРУЗКА (⏳) =========
      class LoadingScene extends Phaser.Scene {
        constructor(){ super("LoadingScene"); }
        preload(){
          const cx = 180, cy = 320;

          // Фон (чтобы не был просто чёрный экран)
          this.cameras.main.setBackgroundColor("#000");

          // Иконка ⏳ и подпись
          const hourglass = this.add.text(cx, cy - 10, "⏳", { fontSize: "48px", color: "#FFFFFF" }).setOrigin(0.5);
          const label = this.add.text(cx, cy + 30, "Loading...", { fontSize: "18px", color: "#FFFFFF" }).setOrigin(0.5);

          // Прогресс-бар
          const box = this.add.rectangle(cx, cy + 70, 240, 16, 0x222222).setStrokeStyle(2, 0x555555).setOrigin(0.5);
          const bar = this.add.rectangle(cx - 120, cy + 70, 1, 12, 0xF7931A).setOrigin(0, 0.5);

          // Анимация «покачивания» песочных часов
          this.tweens.add({ targets: hourglass, angle: { from: -6, to: 6 }, duration: 700, yoyo: true, repeat: -1, ease: "Sine.inOut" });

          this.load.on("progress", (v) => { bar.width = Math.max(1, 240 * v); });
          this.load.on("complete", () => { /* сразу в заставку */ this.scene.start("SplashScene"); });

          // Грузим все ассеты заранее (ключи такие же, как в сценах)
          this.load.image("splashFull", "assets/a.png");
          this.load.image("background", "assets/background.png");
          this.load.image("bull", "assets/bull.png");
          this.load.image("bear", "assets/bear.png");
          this.load.image("speedEffect", "assets/speed.png");
          this.load.image("hitEffect", "assets/hit.png");
        }
      }

      class SplashScene extends Phaser.Scene {
        constructor() { super("SplashScene"); }
        preload() {
          // Дублирующая загрузка не обязательна, но не мешает — всё уже будет в кеше.
          this.load.image("splashFull", "assets/a.png");
          this.load.image("background", "assets/background.png");
        }
        create() {
          // background cover (без черных рамок)
          const bg = this.add.image(180, 320, "background").setOrigin(0.5);
          const bgScale = Math.max(360 / bg.width, 640 / bg.height);
          bg.setScale(bgScale * 1.02);
          this.cameras.main.setRoundPixels(true);

          // уменьшенная, опущенная заставка
          const img = this.add.image(180, 370, "splashFull").setOrigin(0.5);
          const targetW = 360 * 1.0;
          const imgScale = targetW / img.width;
          img.setScale(imgScale);

          // заголовки с обводкой
          const title = this.add.text(180, 120, "Bull vs Bear", {
            fontSize: "42px", fontStyle: "bold", color: "#FFFFFF",
            stroke: "#000000", strokeThickness: 6,
          }).setOrigin(0.5);

          const subtitle = this.add.text(180, 170, "Tap to Win", {
            fontSize: "36px", fontStyle: "bold", color: "#F7931A",
            stroke: "#000000", strokeThickness: 6,
          }).setOrigin(0.5);

          // мягкая анимация
          this.tweens.add({ targets: img, y: "+=10", duration: 1600, yoyo: true, repeat: -1, ease: "Sine.inOut" });
          this.tweens.add({ targets: [title, subtitle], alpha: { from: 0.85, to: 1 }, duration: 1400, yoyo: true, repeat: -1, ease: "Sine.inOut" });

          this.input.once("pointerdown", () => this.scene.start("GameScene"));
          window.FarcadeSDK?.singlePlayer?.actions?.ready?.();
        }
      }

      class GameScene extends Phaser.Scene {
        constructor() { super("GameScene"); }

        preload() {
          this.load.image("bull", "assets/bull.png");
          this.load.image("bear", "assets/bear.png");
          this.load.image("background", "assets/background.png");
          this.load.image("speedEffect", "assets/speed.png");
          this.load.image("hitEffect", "assets/hit.png");
        }

        create() {
          // background cover (без черных рамок)
          const bg = this.add.image(180, 320, "background").setOrigin(0.5);
          const bgScale = Math.max(360 / bg.width, 640 / bg.height);
          bg.setScale(bgScale * 1.02);
          this.cameras.main.setRoundPixels(true);

          // state
          this.level = this.level || 1;
          this.totalPoints = this.totalPoints || 0;

          // outcome state
          this.roundOutcome = null; // 'win' | 'lose'
          this.outcomeText = null;

          // UI texts
          this.levelText = this.add.text(10, 90, "Level: " + this.level, {
            fontSize: "20px", fill: "#FFD700", fontStyle: "bold",
          });
          this.pointsText = this.add.text(10, 120, "Points: " + this.totalPoints, {
            fontSize: "20px", fill: "#FFFFFF", fontStyle: "bold",
          });
          this.scoreText = this.add.text(180, 80, "Score: 0", {
            fontSize: "24px", fill: "#fff", fontStyle: "bold",
            stroke: "#000", strokeThickness: 3
          }).setOrigin(0.5);

          // sprites
          this.bear = this.add.sprite(260, 420, "bear").setScale(0.25).setDepth(0);
          this.bull = this.add.sprite(100, 420, "bull").setScale(0.25).setDepth(1);

          // HP bars
          this.healthBarBackground = this.add.rectangle(180, 40, 210, 20, 0x333333).setStrokeStyle(2, 0x000000);
          this.setupBearHealth();
          this.healthBarFill = this.add.rectangle(180, 40, (this.currentHealth / this.maxHealth) * 200, 16, 0x00ff00);

          this.bullBarBackground = this.add.rectangle(180, 600, 210, 20, 0x333333).setStrokeStyle(2, 0x000000);
          this.setupBullHealth();
          this.bullBarFill = this.add.rectangle(180, 600, (this.bullHealth / this.bullMaxHealth) * 200, 16, 0xff0000);

          // hit effect pool
          this.hitPool = this.add.group({ classType: Phaser.GameObjects.Image, maxSize: 16, runChildUpdate: false });
          for (let i = 0; i < 8; i++) {
            const h = this.add.image(-1000, -1000, "hitEffect").setScale(0.15).setDepth(3);
            h.setActive(false).setVisible(false);
            this.hitPool.add(h);
          }

          // input & motion
          this.tapCount = 0;
          this.lastTapTime = this.time.now;
          this.startTime = null;
          this.gameOverCalled = false;

          this.tweens.add({ targets: this.bull, y: "+=10", yoyo: true, repeat: -1, ease: "Sine.inOut", duration: 800 });
          this.input.on("pointerdown", this.handleTap, this);
          this.input.once("pointerdown", () => { this.startTime = this.time.now; });

          // bear attacks ~1.5s with level-based speedup
          this.bearAttackEvent = this.time.addEvent({
            delay: this.getBearDelay(),
            callback: this.bearAttack,
            callbackScope: this,
            loop: true,
          });

          // Play Again button (hidden until round end)
          this.playAgainBtn = this.createPlayAgainButton();
          this.hidePlayAgainButton();

          // Farcade play_again hook
          window.FarcadeSDK?.on?.("play_again", () => this.nextRound());
        }

        // ——— helpers ———
        getBearDelay() {
          return Math.max(700, 1500 - (this.level - 1) * 120);
        }

        setupBearHealth() {
          const baseMin = 80 + (this.level - 1) * 20;
          const baseMax = 120 + (this.level - 1) * 20;
          this.maxHealth = Phaser.Math.Between(baseMin, baseMax);
          this.currentHealth = this.maxHealth;
        }

        setupBullHealth() {
          this.bullMaxHealth = 100;
          this.bullHealth = this.bullMaxHealth;
        }

        // ——— nicer Play Again button ———
        createPlayAgainButton() {
          const w = 240, h = 56;
          const ORANGE = 0xF7931A;
          const ORANGE_DARK = 0xD9780E;
          const WHITE = 0xFFFFFF;

          makeRoundedButtonTexture(this, "btn_orange", w, h, ORANGE, WHITE, 14, 2);
          makeRoundedButtonTexture(this, "btn_orange_hover", w, h, ORANGE_DARK, WHITE, 14, 2);

          const container = this.add.container(180, 360).setDepth(10);
          const img = this.add.image(0, 0, "btn_orange");
          const label = this.add.text(0, 0, "Play Again", {
            fontSize: "22px", fontStyle: "bold", color: "#ffffff",
            stroke: "#000000", strokeThickness: 3,
          }).setOrigin(0.5);

          img.setInteractive({ useHandCursor: true });
          img.on("pointerover", () => img.setTexture("btn_orange_hover"));
          img.on("pointerout",  () => img.setTexture("btn_orange"));
          img.on("pointerdown", () => {
            this.tweens.add({ targets: container, scale: 0.96, duration: 60, yoyo: true });
            this.nextRound();
          });

          const shadow = this.add.image(2, 4, "btn_orange").setTint(0x000000).setAlpha(0.25);
          container.add([shadow, img, label]);
          return container;
        }

        showPlayAgainButton() {
          this.playAgainBtn.setVisible(true).setAlpha(0);
          this.tweens.add({ targets: this.playAgainBtn, alpha: 1, duration: 200 });
        }
        hidePlayAgainButton() { this.playAgainBtn.setVisible(false); }

        // ——— gameplay ———
        handleTap() {
          if (this.gameOverCalled) return;
          const now = this.time.now;
          const tps = 1000 / (now - this.lastTapTime);
          this.lastTapTime = now;

          this.tapCount++;
          this.scoreText.setText("Score: " + this.tapCount);

          let reduction = Math.floor(this.tapCount / 50);
          let fastDamage = Math.max(3, 10 - reduction);
          let slowDamage = Math.max(1, 5 - reduction);
          let damage = tps > 500 ? fastDamage : slowDamage;
          damage += this.level - 1;
          if (tps > 800) damage *= 2;

          this.tweens.timeline({
            targets: this.bull,
            tweens: [{ x: this.bear.x - 20, duration: 150 }, { x: 100, duration: 150 }],
            onStart: () => window.FarcadeSDK?.singlePlayer?.actions?.hapticFeedback?.(),
            onComplete: () => {
              this.currentHealth = Phaser.Math.Clamp(this.currentHealth - damage, 0, this.maxHealth);
              this.healthBarFill.width = (this.currentHealth / this.maxHealth) * 200;

              this.spawnHit(this.bear.x, this.bear.y);

              this.tweens.add({
                targets: this.bear, tint: 0xff0000, duration: 100, yoyo: true,
                onComplete: () => this.bear.clearTint(),
              });

              if (this.currentHealth <= 0) this.roundOver(false);
            },
          });
        }

        bearAttack() {
          if (this.gameOverCalled) return;

          this.tweens.timeline({
            targets: this.bear,
            tweens: [{ x: this.bull.x + 20, duration: 150 }, { x: 260, duration: 150 }],
            onStart: () => window.FarcadeSDK?.singlePlayer?.actions?.hapticFeedback?.(),
            onComplete: () => {
              let bearDamage = Phaser.Math.Between(5, 10) + (this.level - 1);
              this.bullHealth = Phaser.Math.Clamp(this.bullHealth - bearDamage, 0, this.bullMaxHealth);
              this.bullBarFill.width = (this.bullHealth / this.bullMaxHealth) * 200;

              this.spawnHit(this.bull.x, this.bull.y);

              this.tweens.add({
                targets: this.bull, tint: 0xff0000, duration: 100, yoyo: true,
                onComplete: () => this.bull.clearTint(),
              });

              if (this.bullHealth <= 0) this.roundOver(true);
            },
          });
        }

        // pooled hit effect
        spawnHit(x, y) {
          let hit = this.hitPool.getFirstDead(false);
          if (!hit) {
            hit = this.add.image(-1000, -1000, "hitEffect").setScale(0.15).setDepth(3);
            this.hitPool.add(hit);
          }
          hit.setPosition(x, y).setAlpha(1).setActive(true).setVisible(true);

          this.tweens.add({
            targets: hit, alpha: 0, duration: 120,
            onComplete: () => {
              hit.setActive(false).setVisible(false).setPosition(-1000, -1000);
            },
          });
        }

        roundOver(playerLost = false) {
          if (this.gameOverCalled) return;
          this.gameOverCalled = true;

          // кто победил
          this.roundOutcome = playerLost ? 'lose' : 'win';

          // стопаем атаки
          this.bearAttackEvent?.remove();

          // визуал
          this.tweens.add({ targets: this.bear, alpha: 0.5, duration: 300, yoyo: true, repeat: 2 });
          this.tweens.add({ targets: this.bull, alpha: 0.5, duration: 300, yoyo: true, repeat: 2 });

          // показываем текст исхода
          const text = this.roundOutcome === 'win' ? "You Win!" : "You Lose!";
          const color = this.roundOutcome === 'win' ? "#00FF88" : "#FF5555";
          this.outcomeText = this.add.text(180, 250, text, {
            fontSize: "36px", fontStyle: "bold", color,
            stroke: "#000000", strokeThickness: 5,
          }).setOrigin(0.5).setAlpha(0);
          this.tweens.add({ targets: this.outcomeText, alpha: 1, y: "-=10", duration: 250, ease: "Sine.out" });

          // кнопка повторить/след.уровень
          this.showPlayAgainButton();

          // уведомляем Farcade
          this.time.delayedCall(600, () => {
            window.FarcadeSDK?.singlePlayer?.actions?.gameOver?.({ score: this.tapCount, outcome: this.roundOutcome });
          });
        }

        nextRound() {
          if (this.roundOutcome === 'win') {
            this.totalPoints += this.tapCount;
            this.level++;
          }

          this.pointsText.setText("Points: " + this.totalPoints);
          this.levelText.setText("Level: " + this.level);

          this.setupBearHealth();
          this.healthBarFill.width = (this.currentHealth / this.maxHealth) * 200;
          this.setupBullHealth();
          this.bullBarFill.width = (this.bullHealth / this.bullMaxHealth) * 200;

          this.tapCount = 0;
          this.scoreText.setText("Score: 0");
          this.bull.x = 100;
          this.bear.clearTint(); this.bear.setAlpha(1);
          this.bull.setAlpha(1);

          if (this.outcomeText) { this.outcomeText.destroy(); this.outcomeText = null; }
          this.hidePlayAgainButton();

          this.startTime = null;
          this.gameOverCalled = false;
          this.roundOutcome = null;

          this.bearAttackEvent = this.time.addEvent({
            delay: this.getBearDelay(),
            callback: this.bearAttack,
            callbackScope: this,
            loop: true,
          });

          const lvlUpText = this.add.text(180, 200, "Level " + this.level + "!", {
            fontSize: "32px", fill: "#FFD700", fontStyle: "bold",
            stroke: "#000", strokeThickness: 4
          }).setOrigin(0.5);
          this.tweens.add({ targets: lvlUpText, alpha: 0, y: "-=50", duration: 1000, onComplete: () => lvlUpText.destroy() });
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: 360,
        height: 640,
        parent: "game-container",
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        scene: [LoadingScene, SplashScene, GameScene], // ⏳ загрузка добавлена первой
        physics: { default: "arcade", arcade: { debug: false } },
      };
      new Phaser.Game(config);
    </script>
  </body>
</html>
